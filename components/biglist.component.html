<style>
	.biglist-viewport {
		overflow-y: scroll;
		position: relative;
		height: 600px;
		background-color: #eee;
		opacity: 1;
	}

	.biglist-visible-items {
		background-color: white;
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
	}

	.biglist-visible-items > * {
		border-bottom: 1px solid rgba(0,0,0,0.1);
		box-sizing: border-box;
	}

	.biglist-info {
		position: absolute;
		bottom: 0;
		right: 0;
		background-color: #444;
		color: white;
		padding: 2px 6px;
	}

	.selected {
		background-color: rgba(0,0,255,0.25);
	}
</style>
<div class="biglist-viewport" data-event="scroll:_component_.update">
	<div class="biglist-scroller">
		<div class="biglist-visible-items" data-children>
			<div data-list="_component_.visible_items" data-bind="class(selected)=.selected" style="padding: 8px; display: flex;">
				<input type="checkbox" data-bind="value=.selected">
				<input style="border: 0; background: transparent; border-color: rgba(0,0,0,0.25);" data-bind="style(fontSize)=.fontSize;value=.caption">
			</div>
		</div>
	</div>
</div>
<div class="biglist-info">
	Progress: 
	<span data-bind="text=_component_.t"></span>
	Scroll Position: 
	<span data-bind="text=_component_.position"></span>
	Items in DOM:
	<span data-bind="text=_component_.rows_to_show"></span>
	Total Items: 
	<span data-bind="text=_component_.list.length"></span>
</div>
<script>
/*
	TODO
	- implement lists that are bottom-pinned
	- handle items being added to the top/bottom of the list gracefully
	- implement binding transparently -- so you can just data-bind="value=path.to.list"
*/
	const viewport = findOne('.biglist-viewport');
	const scroller = findOne('.biglist-scroller');
	const visible_item_container = findOne('.biglist-visible-items');

	const position = component.style.position;
	if(!position || !(position.match(/absolute|fixed|relative/))) {
		component.style.position = 'relative';
	}

	data = Object.assign({pin: 'top'}, data);
	if (!data.list) {
		data.minRowHeight = 35;
		data.list = [];
		for (var i = 0; i < 1000; i++) {
			data.list.push({
				caption: "Item " + i,
				fontSize: (Math.random() * 36 + 12) + 'px',
			});
		}
	}

	data.update = update;
	register(data);

	function update() {
		const rows_to_show = Math.min(data.list.length, Math.floor(viewport.offsetHeight / data.minRowHeight + 2));
		const scroller_height = data.list.length * data.minRowHeight;
		scroller.style.height = scroller_height + 'px';
		const position = viewport.scrollTop / data.minRowHeight;
		const t = viewport.scrollTop / (scroller_height - viewport.offsetHeight);
		const visible_items = data.list.slice(Math.floor(position), Math.floor(position) + rows_to_show);
		set('visible_items', visible_items);
		set('position', position.toFixed(2));
		set('rows_to_show', rows_to_show);
		set('t', t);
		const total_height = b8r.makeArray(visible_item_container.children)
													  .map(elt => elt.offsetHeight).reduce((a, b) => a + b);
    const rows = b8r.makeArray(visible_item_container.children).filter(elt => !elt.matches('[data-list]'));
    const offsetElementIndex = Math.floor(rows.length * t);
		const offsetElement = rows[offsetElementIndex] || rows.pop();
		const pin_top_offset = viewport.scrollTop;
		const pin_bottom_offset = viewport.scrollTop + viewport.offsetHeight - total_height + offsetElement.offsetHeight;
		console.log(position % 1, offsetElement);
		const offset = t * pin_bottom_offset + (1 - t) * pin_top_offset - (position % 1) * offsetElement.offsetHeight;
		visible_item_container.style.top = offset + 'px';
	}

	update();
</script>