<!--
# Unaligned Grid

A quick CSS experiment to produce a tidy, uniformly spaced, but irregular grid which allows
 arbitrary numbers of elements to be packed into an arbitrary width and never gets ragged.
-->
<style>
  .unaligned-grid-component {
    position: relative;
    display: flex;
    width: 100%;
    height: 512px;
    overflow-y: overlay;
    flex-wrap: wrap;
    align-content: flex-start;
    justify-content: center;
    padding-top: 20px;
    margin-top: -20px;
  }

  .unaligned-grid-item {
    display: inline-block;
    font-size: 60px;
    height: 150px;
    line-height: 150px;
    text-align: center;
    margin: 4px;
    border: 1px solid rgba(0,0,0,0.05);
    border-radius: 4px;
    flex: 1 0 150px;

    color: white;
    transition: 0.25s ease-out;
    text-shadow: 0 1px 1px black;
    max-width: 400px;
  }

  .unaligned-grid-item:nth-child(2n) {
    flex-basis: 250px;
  }

  .unaligned-grid-item:nth-child(3n) {
    flex-basis: 250px;
  }

  .unaligned-grid-item:nth-child(5n) {
    flex-basis: 150px;
  }
</style>
<div
  class="unaligned-grid-item fade-in"
  data-list="_component_.items:id"
  data-bind="text=.id;style(backgroundColor)=.backgroundColor"
>
</div>
<script>
  const color = require('../lib/color.js');
  const scroll = require('../lib/animated-scroll.js');
  let id = 0;
  set('items', []);

  setInterval(() => {
    if (id >= 30) {
      id = 0;
      set('items', []);
    }

    const colors = color.cssColorNames();
    const backgroundColor = colors[Math.floor(Math.random() * colors.length)];
    get('items').push({id: ++id, backgroundColor});
    touch('items');
    b8r.after_update(() => scroll.into_view(findOne('.unaligned-grid-item:nth-last-child(2)')));
  }, 500);
</script>
