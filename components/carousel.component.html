<!--
# carousel

Copyright Â©2016-2017 Tonio Loewald
-->
<style>
	.carousel {
		width: 100%;
		min-height: 400px;
		position: relative;
		text-align: center;
		perspective: 1000px;
		overflow: hidden;
	}

	.carousel-item {
		position: absolute;
		top: 50%;
		left: 50%;
	}

	.carousel-item * {
		pointer-events: none;
	}

	.carousel-item.carousel-current * {
		pointer-events: all;
	}


	.carousel > .carousel-test {
		display: block;
		background-color: rgba(255,255,255,0.5);
		width: 30%;
		height: 90%;
		border-radius: 6px;
		width: 100px;
		transition: width 0.2s ease-out;
		box-sizing: border-box;
		padding: 20px;
	}

	.carousel > .carousel-test.carousel-current {
		width: 200px;
		border: 4px solid rgba(0,0,0,0.5);
	}

	.carousel > .carousel-test > button {
		margin: 10px;
	}
</style>
<div
	class="carousel"
	data-event="
		mousedown:_component_.dragStart;
		mouseup:_component_.setTarget;
		change:_component_.change;
	"
	data-children
>
	<div
		class="carousel-test"
		data-list="_component_.items:id"
		data-bind="
			style(backgroundColor)=.bg_color;
		"
	>
		<button data-event="click:_component_.add">Add item!</button><br>
		<button data-event="click:_component_.remove">Delete this item!</button>
	</div>
</div>
<div style="text-align: center; padding: 20px;" data-bind="show_if=_component_.show_slider">
	<input type="range" min=0 max=1 step=0.0001 data-event="input,change:_component_.update" />
</div>
<script>
/* global b8r, findOne, find, component, set, data */
'use strict';

	b8r.json('lib/css-color-names.json').then(colors => {
		const colorNames = Object.keys(colors);
		const items = [];
		let id = 0;

		const add = () => {
			items.push({
				id,
				bg_color: colorNames[Math.floor(Math.random() * colorNames.length)],
				width: Math.random() * 200 + 100,
			});
			id += 1;
		};

		const remove = (evt, element) => {
			const id = items.indexOf(b8r.getListInstance(element));
			items.splice(id, 1);
			set({items});
		};

		for(let i = 0; i < 4; i++) {
			add();
		}
		set({
			items,
			add: () => {
				add();
				set({items});
				target = items.length - 1;
				snapToTarget();
			},
			remove,
		});
	});

	const max_rotation = parseFloat(component.getAttribute('data-carousel-rotation') || 0);
	const max_distance = parseFloat(component.getAttribute('data-carousel-distance') || 50);
	const inner_offset = parseFloat(component.getAttribute('data-carousel-inner-offset') || 155);
	const item_offset = parseFloat(component.getAttribute('data-carousel-offset') || 100);
	const item_spacing = parseFloat(component.getAttribute('data-carousel-spacing') || 10);
	const centered_at_start = component.hasAttribute('data-carousel-centered') || true;
	const show_slider = component.hasAttribute('data-show-slider');
	const min_scale = component.getAttribute('data-carousel-minscale') || 1;

	function ease_in_out(t) {
		var s = t > 0 ? 0.5 : -0.5;
		var a = Math.abs(t);
		return (1 - Math.cos(a * Math.PI)) * s;
	}

	function ease_out(t) {
		var s = t > 0 ? 1 : -1;
		var a = Math.abs(t);
		return (1 - Math.cos(a * 0.5 * Math.PI)) * s;
	}

	function ease_in(t) {
		return 1 - ease_out(1 - t);
	}

	// offset 0: element is in the center
	// offset 1: the element is one to the right of center
	// offset 0.5: element is halfway between center and offset 1
	// offset -2: the element is two to the left of center
	function setItemPosition(element, offset) {
		var abs_offset = Math.abs(offset);
		if (abs_offset < 0.5) {
			element.classList.add('carousel-current');
		} else {
			element.classList.remove('carousel-current');
		}
		var dx = 0;
		var dz = 0;
		var ry = 0;
		if( abs_offset > 0.01) {
			dx = abs_offset < 1 ?
					 offset * (inner_offset + item_spacing) :
					 (inner_offset + item_spacing + (abs_offset - 1) * (item_offset + item_spacing)) * (offset < 0 ? -1 : 1);
			if (abs_offset < 1) {
				dz = -max_distance * ease_in_out(abs_offset);
				ry = ease_in(offset) * -max_rotation;
			} else {
				dz = -max_distance;
				ry = offset < 0 ? max_rotation : -max_rotation;
			}
		} else {
			offset = 0;
			abs_offset = 0;
		}
		var s = 1 - Math.min(abs_offset, 1 - min_scale);
		element.style.transform = `translateX(-50%) translateY(-50%) translateX(${dx}px) translateZ(${dz}px) rotateY(${ry}deg) scale(${s})`;
		element.style.zIndex = Math.round(30 - 10 * abs_offset);
	}

	var position = null;
	var target = 0;
	var items;
	const carousel = findOne('.carousel');
	const slider = findOne('input');
	const {component_id} = data;

	const clamp = (x, min, max) => x < min ? min : (x > max ? max : x);

	function init() {
		const child_selector = component.getAttribute('child-selector') || '.carousel > div';
		items = find(child_selector).filter(elt => !elt.matches('[data-list]'));
		items.forEach(element => element.classList.add('carousel-item'));
		if (position === null) {
			if (items.length) {
				position = centered_at_start && items.length ? Math.floor((items.length - 1) * 0.5) : 0;
			}
		} else {
			if (position > items.length - 1) {
				target = items.length - 1;
				snapToTarget();
			}
		}
		target = Math.min(target, items.length - 1);
		updateItems();
	}

	function updateItems(){
		items.forEach((element, idx) => {
			setItemPosition(element, idx - position);
		});
		slider.value = position / (items.length - 1);
	}

	function snapToTarget(){
		if (Math.abs(position - target) < 0.01) {
			position = target;
		} else {
			position = (position * 15 + target) / 16;
			requestAnimationFrame(snapToTarget);
		}
		updateItems();
	}

	init();

	let drag_x;
	let drag_dx;

	const dragging = () => component.matches('.carousel-dragging');

	const dragOff = () => {
		component.classList.remove('carousel-dragging');
		b8r.offAny('mouseup', `${component_id}.setTarget`);
		b8r.offAny('mousemove', `${component_id}.drag`);
		b8r.offAny('mouseleave', `${component_id}.dragEnd`);
	};

	const dragOn = () => {
		component.classList.add('carousel-dragging');
		b8r.onAny('mouseup', `${component_id}.setTarget`);
		b8r.onAny('mousemove', `${component_id}.drag`);
		b8r.onAny('mouseleave', `${component_id}.dragEnd`);
	};

	set({
		setTarget: evt => {
			if (!dragging()) {
				return true;
			}
			dragOff();
			if (Math.abs(drag_dx) < 0.1) {
				let child = evt.target;
				while (child.parentElement && items.indexOf(child) === -1) {
					child = child.parentElement;
				}
				target = items.indexOf(child);
				snapToTarget(child);
			} else {
				b8r.trigger('change', slider);
			}
		},
		dragStart: evt => {
			if (!evt.target.matches('.carousel-item')) {
				return true;
			}
			drag_x = evt.pageX;
			drag_dx = 0;
			dragOn();
		},
		drag: evt => {
			if (dragging()) {
				let dx = evt.pageX - drag_x;
				drag_x = evt.pageX;
				drag_dx += dx;
				position = clamp(position - dx * 4 / carousel.offsetWidth, -0.125, items.length - 0.875);
				updateItems();
			}
		},
		dragEnd: evt => {
			if (evt.target === carousel && dragging()) {
				dragOff();
				b8r.trigger('change', slider);
			}
		},
		change: init,
		update: evt => {
			position = slider.value * (items.length - 1);
			updateItems();
			if(evt.type === 'change') {
				target = Math.round(position);
				snapToTarget();
			}
		}
	});
</script>
