<!--
# RAW Viewer

Sorry, this demo is macOS and electron only.

1. It finds all the `NEF`, `CR2`, and `DNG` files using spotlight `mdfind`
2. It extracts metadata using `mdls` (sadly not EXIF data directly yet so, in particular,
   Orientation data is not wholly accurate and some portrait photos will be upside-down)
3. It generates thumbnails using `qlmanage -t -o /tmp/...` (it would be even faster if we
   could bypass the file system entirely, but that would entail writing a native plugin)
4. It shows you the previews using `biggrid`
5. It gets Finder tags using `xattr` and displays
   `star`, `favorite`, and `flag` comments (but doesn't show color tags yet nor allow you to
   create/edit custom tags)
6. It gets Finder comments using `xattr` (but you can't edit the comments yet)
7. It uses `jsfeat` to try to detect blurred or otherwise bad photos by
  1. converting the image to grayscale using `jsfeat.imgproc.grayscale`
  2. using `jsfeat.imgproc.equalize_histogram` to compensate for photos with close tones or
     poor exposure
  3. `jsfeat.yape` to try to find detail in the image
  Photos suspected of being poor are marked with the "yape score".

The previews are generated asynchronously up to three at a time. (I picked three
because chances are you have at least four virtual cores, but it looks like sips
parallelizes anyway ‚Äî a little experimentation seems to indicate that doing more than
one file at a time has some benefit.)

Previews are generated in random order, but priority is given to previews for
grid cells that are currently in view.

## To Do

* UI Refinements (toolbar, explicit toggle for metadata)
* List filtering based on file tags, dates, etc.
* Option to show all metadata
* Show color tags
* Restrict to a directory / volume etc. (especially for importing from cards)
* It would be nice to get actual EXIF data so all images could be rendered with correct orientation
* xmp support
* Some kind of quick-and-dirty scheme to detect over- and under- exposed images
* Some kind of quick‚Äîand-dirty scheme to detect out-of-focus images
* Automatic generation of "virtual tags" for lens, focal length (wide, normal, telephoto, ultrawide,
  long), aperture (wide open, normal, small), shutter speed, camera, year, year+month, location
  (if data available)
* Edit Finder comments directly (and possibly allow file renaming)
-->
<style>
  .raw-viewer-component {
    display: flex;
  }

  .example.raw-viewer-component {
    height: 480px;
  }

  .raw-viewer-scroller {
    flex: 1 1 auto;
    line-height: 0;
    overflow-y: scroll;
    overflow-y: overlay;
    text-align: center;
    padding: 8px;
  }

  .raw-viewer-scroller.one-column {
    flex: 0 0 160px;
  }

  .raw-viewer-tile {
    margin: 0;
    padding: 0;
    display: inline-block;
    width: 128px;
    height: 128px;
    overflow: hidden;
    position: relative;
    background: #ddd;
    box-shadow: 0 2px 4px rgba(255,255,255,0.5);
    margin: 8px;
  }

  .raw-viewer-tile > span {
    position: absolute;
    display: block;
    color: white;
    background: rgba(0,0,0,0.5);
    left: 0;
    right: 0;
    bottom: 0;
    text-align: center;
    white-space: nowrap;
    text-overflow: ellipsis;
    line-height: 20px;
    opacity: 0.5;
    transition: 0.1s ease-out;
  }

  .raw-viewer-tile:hover > span,
  .raw-viewer-tile:focus > span {
    opacity: 1;
  }

  .raw-viewer-tile:focus {
    box-shadow: none;
    outline: none;
  }

  .raw-viewer-component img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .raw-viewer-detail {
    flex: 1 1 auto;
    position: relative;
  }

  .raw-viewer-detail .icon-cross2 {
    position: absolute;
    color: white;
    font-size: 24px;
    line-height: 32px;
    width: 32px;
    height: 32px;
    text-align: center;
    top: 10px;
    right: 10px;
    cursor: default;
    background: rgba(0,0,0,0.5);
    border-radius: 2px;
    opacity: 0.5;
    transition: 0.1s ease-out;
  }

  .raw-viewer-detail .metadata {
    position: absolute;
    bottom: 10px;
    right: 10px;
    color: white;
    background: rgba(0,0,0,0.75);
    padding: 5px;
    border-radius: 5px;
    opacity: 0.5;
    transition: 0.1s ease-out;
  }

  .raw-viewer-detail .icon-cross2:hover,
  .raw-viewer-detail .metadata:hover {
    opacity: 1;
  }

  .raw-viewer-detail th {
    text-align: right;
    padding-right: 5px;
  }

  .raw-viewer-detail img {
    object-fit: contain;
    transition: opacity 0.5s ease-out;
  }

  .raw-viewer-detail.loading img {
    opacity: 0.75;
    image-rendering: pixelated;
  }

  .raw-viewer-tile.loading:after {
    content: " ";
    display: block;
    position: absolute;
    top: 50%;
    left: 50%;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0);
    transform: translateX(-50%) translateY(-50%);
    animation: infinite loading 2s ease-in;
  }

  @keyframes loading {
    0% {
      width: 25%;
      height: 25%;
      background: rgba(0,0,0,0);
    }
    50% {
      background: rgba(0,0,0,0.25);
    }
    100% {
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0);
    }
  }

  .raw-viewer-toolbar > * {
    border: 0 !important;
    background: none !important;
    line-height: 28px;
    font-size: 14px;
    padding: 0 8px;
    color: white;
    opacity: 0.8;
    border-radius: 4px;
  }

  .raw-viewer-toolbar input {
    display: none;
  }

  .raw-viewer-toolbar input+* {
    filter: brightness(2) grayscale(100%);
    transition: 0.25s ease-out;
  }

  .raw-viewer-toolbar input:checked+* {
    opacity: 1.0;
    filter: none;
  }

  .blurred:after {
    content: attr(data-yape);
    background: rgba(255,0,0,0.5);
    color: white;
    position: absolute;
    line-height: 14px;
    padding: 2px 4px;
    top: 0;
    right: 0;
  }
</style>
<div
  class="raw-viewer-scroller"
  data-bind="class(one-column)=_component_.rawfile"
  data-biggrid-padding="16,16"
>
  <div
    class="raw-viewer-tile"
    data-bind="
      class(loading)=.generating_preview;
      class(blurred)=.blurred;
      data(yape)=.yape;
    "
    data-list="_component_.slice(_component_.rawfiles):_auto_"
    data-event="mouseup,keydown(Space):_component_.pick"
    tabindex="0"
  >
    <img data-bind="
      img=${.preview};
    ">
    <span data-bind="text=.filename"></span>
  </div>
</div>
<div
  class="raw-viewer-detail"
  data-bind="
    class(loading)=_component_.rawfile.generating_fullsize;
    show_if=_component_.rawfile;
  "
>
  <img data-bind="img=_component_.rawfile.fullsize">
  <div
    class="icon-cross2"
    data-event="mouseup:_component_.closeDetail"
  ></div>
  <table
    class="metadata"
  >
    <tr data-bind="show_if=_component_.rawfile.metadata.Name">
      <th>Display Name</th>
      <td data-bind="text=_component_.rawfile.metadata.Name"></td>
    </tr>
    <tr data-bind="show_if=_component_.rawfile.metadata.CreationDate">
      <th>Creation Date</th>
      <td data-bind="timestamp()=_component_.rawfile.metadata.CreationDate"></td>
    </tr>
    <tr data-bind="show_if=_component_.rawfile.metadata.Size">
      <th>Finder Comment</th>
      <td data-bind="text=${_component_.rawfile.metadata.FinderComment}"></td>
    </tr>
    <tr data-bind="show_if=_component_.rawfile.metadata.Model">
      <th>Camera</th>
      <td data-bind="text=_component_.rawfile.metadata.Model"></td>
    </tr>
    <tr data-bind="show_if=_component_.rawfile.metadata.LensModel">
      <th>Lens</th>
      <td data-bind="text=_component_.rawfile.metadata.LensModel"></td>
    </tr>
    <tr data-bind="show_if=_component_.rawfile.metadata.FocalLength">
      <th>Focal Length</th>
      <td data-bind="text=${_component_.rawfile.metadata.FocalLength}mm"></td>
    </tr>
    <tr data-bind="show_if=_component_.rawfile.metadata.FocalLength35mm">
      <th>35mm equiv.</th>
      <td data-bind="text=${_component_.rawfile.metadata.FocalLength35mm}mm"></td>
    </tr>
    <tr data-bind="show_if=_component_.rawfile.metadata.FNumber">
      <th>Aperture</th>
      <td data-bind="text=_component_.rawfile.metadata.FNumber"></td>
    </tr>
    <tr data-bind="show_if=_component_.rawfile.metadata.ExposureTimeSeconds">
      <th>Shutter Speed</th>
      <td data-bind="text=_component_.rawfile.metadata.ExposureTimeSeconds"></td>
    </tr>
    <tr data-bind="show_if=_component_.rawfile.metadata.ISOSpeed">
      <th>ISO</th>
      <td data-bind="text=_component_.rawfile.metadata.ISOSpeed"></td>
    </tr>
    <tr data-bind="show_if=_component_.rawfile.metadata.PixelWidth">
      <th>Resolution</th>
      <td data-bind="text=${_component_.rawfile.metadata.PixelWidth} ‚®â ${_component_.rawfile.metadata.PixelHeight}"></td>
    </tr>
    <tr data-bind="show_if=_component_.rawfile.metadata.Size">
      <th>File Size</th>
      <td data-bind="bytes=${_component_.rawfile.metadata.Size}"></td>
    </tr>
    <tr>
      <td class="raw-viewer-toolbar" colspan="2">
        <button data-event="click:_component_.edit">Edit</button>
        <button data-event="click:_component_.reveal">Reveal</button>
        <button data-event="click:_component_.preview">Preview</button>
        <label>
          <input
            type="checkbox"
            data-bind="checked=_component_.rawfile.tags.favorite"
            data-event="change:_component_.tag"
          ><span>‚ù§Ô∏è</span></label>
        <label>
          <input
            type="checkbox"
            data-bind="checked=_component_.rawfile.tags.star"
            data-event="change:_component_.tag"
          ><span>‚≠êÔ∏è</span></label>
        <label>
          <input
            type="checkbox"
            data-bind="checked=_component_.rawfile.tags.flag"
            data-event="change:_component_.tag"
          ><span>üö©</span></label>
        <button data-event="click:_component_.trash" style="float: right">Trash</button>
      </td>
    </tr>
  </table>
</div>
<script>
  /* global require, console, get, set, component, b8r, touch */
  'use strict';

  const biggrid = require('../lib/biggrid.js');
  const {imagePromise} = require('../source/b8r.imgSrc.js');
  const jsfeat = require('../third-party/jsfeat-min.js');

  if (! require.electron || window.process.platform !== 'darwin') {
    return;
  }

  if (! component.matches('.example')) {
    document.body.style.overflow = 'hidden';
  }

  const fs = require.globalRequire('fs');
  const {exec} = require.globalRequire('child_process');

  const MAX_PROCESSING = 4;
  const PREVIEW_SIZE = 256;
  const PREGENERATE_PREVIEWS = false;
  const PREVIEW_PATH = `/tmp/thumbs-${PREVIEW_SIZE}`;
  const FULLSIZE_PATH = `/tmp/fullsize`;
  let rawfiles_visible = [];
  let processing = 0;

  const canvas = b8r.create('canvas');
  canvas.width = 256;
  canvas.height = 256;
  const context2d = canvas.getContext('2d');

  const reportError = err => { if (err) console.error(err); };

  const process = rawfile => {
    const {_auto_, filepath, tags} = rawfile;
    const preview = `${PREVIEW_PATH}/${rawfile.filename}.png`;
    //console.log('generating', preview, {processing, waiting: waiting.length});
    set(`rawfiles[_auto_=${_auto_}].generating_preview`, true);

    const done = () => {
      // if the component has been removed, allows processing to stop cleanly
      if(document.body.contains(component)) {
        set(`rawfiles[_auto_=${_auto_}].generating_preview`, false);
        set(`rawfiles[_auto_=${_auto_}].preview`, 'file://' + preview);
        imagePromise('file://' + preview).then(img => {
          /*
          // FAST
          jsfeat.fast_corners.set_threshold(50);
          // YAPE06
          jsfeat.yape06.laplacian_threshold = 25;
          jsfeat.yape06.min_eigen_value_threshold = 75;
          */
          // YAPE
          jsfeat.yape.init(256, 256, 3, 1);

          const corners = [], border=2;
          // you should use preallocated keypoint_t array
          for(let i = 0; i < 256 * 256; ++i) {
            corners[i] = new jsfeat.keypoint_t(0,0,0,0);
          }
          const img_u8 = new jsfeat.matrix_t(256, 256, jsfeat.U8_t | jsfeat.C1_t);
          context2d.drawImage(img, 0, 0, 256, 256);
          const imageData = context2d.getImageData(0, 0, 256, 256);
          jsfeat.imgproc.grayscale(imageData.data, 256, 256, img_u8);
          jsfeat.imgproc.equalize_histogram(img_u8, img_u8);
          // const fast = jsfeat.fast_corners.detect(img_u8, corners, border);
          // const yape06 = jsfeat.yape06.detect(img_u8, corners, border);
          const yape = jsfeat.yape.detect(img_u8, corners, border);
          set(`rawfiles[_auto_=${_auto_}].yape`, yape);
          if (yape < 100) {
            set(`rawfiles[_auto_=${_auto_}].blurred`, true);
          }
        });
        processing -= 1;
        dequeue();
      }
    };

    const get_preview = () => {
      fs.access(preview, fs.constants.R_OK, err => {
        if (err) {
          // const rot = rawfile.metadata.Orientation === '1' ? -90 : 0;
          exec(
            `mkdir -p ${PREVIEW_PATH} && ` +
            `qlmanage -t -s=${PREVIEW_SIZE} -o ${PREVIEW_PATH} "${filepath}"`,
            // `sips -s format jpeg -r ${rot} -s formatOptions 75 -Z ${PREVIEW_SIZE} "${filepath}" --out "${preview}"`,
            err => {
              if (err) {
                console.error(`${filepath} RAW conversion failed`, err);
              } else {
                done();
              }
            }
          );
        } else {
          done();
        }
      });
    };

    exec(
      `mdls "${filepath}"`,
      (err, stdout) => {
        if (err) {
          console.error(`${filepath} metadata extraction failed`, err);
        } else {
          const metadata = {};
          stdout.split('\nkMD').forEach(item => {
            let [key, value] = item.split('=').map(s => s.trim());
            key = key.replace(/^(FS)?(Item)?(FS)?(Content)?(Acquisition)?(Display)?/, '');
            if (key && !value.match(/^(\s+|\(null\))$/)) {
              metadata[key] = value.indexOf('(') === -1
                              ? value.match(/^"*(.*?)"*$/m)[1] // strip outer quotation marks
                              : value.match(/\w[^,)"]*/g).map(s => s.trim());
            }
          });
          if (metadata.UserTags) {
            metadata.UserTags.forEach(t => tags[t] = true);
            touch(`rawfiles[_auto_=${_auto_}].tags`);
          }
          if (metadata.ExposureTimeSeconds < 1) {
            metadata.ExposureTimeSeconds = '1/' + Math.round(1/metadata.ExposureTimeSeconds);
          }
          set(`rawfiles[_auto_=${_auto_}].metadata`, metadata);
          get_preview();
        }
      }
    );
  };

  const dequeue = () => {
    if (processing >= MAX_PROCESSING) {
      return;
    }

    const waiting = rawfiles_visible.filter(f => ! f.preview);
    const list = waiting.length || ! PREGENERATE_PREVIEWS ? waiting : get('rawfiles').filter(f => ! f.preview);
    while(processing < MAX_PROCESSING && list.length) {
      const rand = Math.floor(Math.random() * list.length);
      processing += 1;
      const rawfile = list.splice(rand, 1)[0];
      process(rawfile);
      // if list is waiting_on_screen we also need to remove item from waiting
      if (waiting.indexOf(rawfile) > -1) {
        waiting.splice(waiting.indexOf(rawfile), 1);
      }
    }
  };

  const findFiles = extension => {
    const rawfiles = get('rawfiles');
    exec(
      `mdfind "kMDItemDisplayName == '*.${extension}'"`,
      {maxBuffer: 1024 * 10000}, // 10MB buffer because
      (err, stdout) => {
        if (err) {
          console.error('spotlight search failed', err);
        } else {
          stdout.split('\n').
          filter(f => !!f).
          forEach(
            filepath => {
              const filename = filepath.split('/').pop();
              rawfiles.push({
                filename,
                basename: filename.split('.').slice(0,-1).join('.'),
                filepath,
                tags: {},
              });
            }
          );
          set({rawfiles});
        }
      }
    );
  };

  const pick = evt => {
    const rawfile = b8r.getListInstance(evt.target);

    if (!rawfile.fullsize) {
      const {filepath} = rawfile;
      rawfile.fullsize = rawfile.preview;
      const fullsize = `${FULLSIZE_PATH}/${rawfile.basename}.jpg`;
      rawfile.generating_fullsize = true;
      const rot = rawfile.metadata.Orientation === '1' ? -90 : 0;
      exec(
        `mkdir -p ${FULLSIZE_PATH} && ` +
        `sips -s format jpeg -r ${rot} -s formatOptions 90 "${filepath}" --out "${fullsize}"`,
        err => {
          if (err) {
            console.error(`${filepath} RAW conversion failed`, err);
          } else {
            imagePromise('file://' + fullsize).
            then(() => {
              rawfile.generating_fullsize = false;
              rawfile.fullsize = 'file://' + fullsize;
              touch('rawfile');
            });
          }
        }
      );
    } else {
      rawfile.generating_fullsize = false;
    }
    set({rawfile});
    // force grid to resize
    touch('rawfiles');
  };

  const closeDetail = () => {
    set('rawfile', null);
    touch('rawfiles');
  };

  const slice = (list, container) => {
    rawfiles_visible = biggrid.slice(list, container);
    dequeue();
    return rawfiles_visible;
  };

  const edit = () => {
    exec(`open "${get('rawfile.filepath')}"`, reportError);
  };
  const reveal = () => {
    exec(`open -R "${get('rawfile.filepath')}"`, reportError);
  };
  const preview = () => {
    exec(`qlmanage -p "${get('rawfile.filepath')}"`, reportError);
  };
  const tag = () => {
    const {tags, filepath} = get('rawfile');
    const xml = b8r.filterKeys(tags, v => v).map(t => `<string>${t}</string>`).join('');
    console.log(xml);
    exec(`xattr -w com.apple.metadata:_kMDItemUserTags '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"><plist version="1.0"><array>${xml}</array></plist>' "${filepath}"`, reportError);
  };
  const trash = () => {
    const rawfile = get('rawfile');
    const rawfiles = get('rawfiles');
    rawfiles.splice(rawfiles.indexOf(rawfile), 1);
    exec(`mv "${rawfile.filepath}" ~/.Trash`);
    closeDetail();
    set('rawfile', null);
    touch('rawfiles');
  };

  set({slice, pick, closeDetail, rawfiles: [], edit, reveal, preview, tag, trash});

  findFiles('NEF');
  findFiles('DNG');
  findFiles('CR2');
</script>
